#using System.Text
#using Goedel.Mesh
#using Goedel.Protocol
#using Goedel.Utilities
#using Goedel.Cryptography
#using Goedel.Cryptography.Dare
#xclass ExampleGenerator ExampleGenerator
#% static ExampleGenerator Instance(StreamWriter output)  => new ExampleGenerator () { _Output = output};

#file UDFVariousUDF "Examples\\UDFVariousUDF.md" CreateExamples Example
~~~~
#{Example.ResultUDFNonce.Key}
#{Example.ResultUDFSecret.Key}
#{Example.ResultUDFSecret.Shares[0]}
#{Example.ResultDigestSHA2.Digest}
#{Example.ResultDigestSHA3.Digest}
#{Example.ResultCommitSHA2.Digest}
~~~~
#end file


#file UDFNonce "Examples\\UDFNonce.md" CreateExamples Example
~~~~
#{Example.ResultUDFNonce.Key}
~~~~
#end file

#file UDFEncrypt "Examples\\UDFEncrypt.md" CreateExamples Example
~~~~
#{Example.ResultUDFSecret.Key}
~~~~
#end file

#file UDFShare "Examples\\UDFShare.md" CreateExamples Example
~~~~
Key:     #{Example.ResultUDFSecret.Key}
Share 0: #{Example.ResultUDFSecret.Shares[0]}
Share 1: #{Example.ResultUDFSecret.Shares[1]}
Share 2: #{Example.ResultUDFSecret.Shares[2]}
~~~~
#end file

#file UDFDigest "Examples\\UDFDigest.md" CreateExamples Example
~~~~
SHA-2-512: #{Example.ResultDigestSHA2.Digest}
SHA-3-512: #{Example.ResultDigestSHA3.Digest}
~~~~
#end file

#file UDFAuthenticator "Examples\\UDFAuthenticator.md" CreateExamples Example
~~~~
SHA-2-512: #{Example.ResultCommitSHA2.Digest}
~~~~
#end file

#file UDFDigestURI "Examples\\UDFDigestURI.md" CreateExamples Example
udf:#{Example.ResultDigestSHA2.Digest}
#end file

#file UDFDigestLocator "Examples\\UDFDigestLocator.md" CreateExamples Example
udf://#{Example.ResultDigestSHA2.Digest}
#end file

#file UDFDigestEARLRAW "Examples\\UDFDigestEARL-raw.md" CreateExamples Example
udf://example.com/#{Example.ResultUDFEARL.Key}#!
#end file

#file UDFDigestEARL "Examples\\UDFDigestEARL.md" CreateExamples Example
udf://example.com/#{Example.ResultUDFEARL.Key}

The UDF locator is resolved by appending it to the Web Service Endpoint
for the domain example.com according to the DNS Web Service discovery
mechanism discussed in section XX

https://example.com/.well-known/mmm-udf/#{Example.ResultUDFEARL.Identifier}
#end file

#file UDFsin "Examples\\UDFsin.md" CreateExamples Example

For example, Example Inc holds the domain name example.com and has deployed a private CA whose root of trust is a PKIX certificate with the UDF fingerprint MB2GK-6DUF5-YGYYL-JNY5E-RWSHZ.
Alice is an employee of Example Inc., she uses three email addresses:
alice@example.com
A regular email address (not a SIN).
alice@mm--mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
A strong email address that is backwards compatible.
alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
A strong email address that is backwards incompatible.


#end file

#file UDFSplit "Examples\\UDFSplit.md" CreateExamples Example

Alice decides to encrypt an important document and split the encryption key so that
there are five key shares, three of which will be required to recover the key.

~~~~
Alice's master secret is#{Example.UDFSplitSecret.Key.ToStringBase16FormatHex()}
~~~~

This has the UDF representation:

#{Example.UDFSplitSecret.UDFKey}

The master secret is converted to an integer applying network byte order conventions.
Since the master secret is 128 bits, it is guaranteed to be smaller than the modulus.
The resulting value becomes the polynomial value a0.

Since a threshold of three shares is required, we will need a second order polynomial.
The co-efficients of the polynomial a1, a2 are random numbers smaller than the 
modulus:

~~~~
a0 = #{Example.UDFSplitPolynomial[0]}
a1 = #{Example.UDFSplitPolynomial[1]}
a2 = #{Example.UDFSplitPolynomial[2]}
~~~~

The master secret is the value f(0) = a0. The key shares are the values f(1), f(2)...f(5):

~~~~
f(1) = #{Example.UDFSplitShares[0].Value}
f(2) = #{Example.UDFSplitShares[1].Value}
f(3) = #{Example.UDFSplitShares[2].Value}
f(4) = #{Example.UDFSplitShares[3].Value}
f(5) = #{Example.UDFSplitShares[4].Value}
~~~~

The first byte of each share specifies the recovery information (quorum, x value), the
remaining bytes specify the share value in network byte order:

~~~~
f(1) = #{Example.UDFSplitShares[0].Key.ToStringBase16FormatHex()}
f(2) = #{Example.UDFSplitShares[1].Key.ToStringBase16FormatHex()}
f(3) = #{Example.UDFSplitShares[2].Key.ToStringBase16FormatHex()}
f(4) = #{Example.UDFSplitShares[3].Key.ToStringBase16FormatHex()}
f(5) = #{Example.UDFSplitShares[4].Key.ToStringBase16FormatHex()}
~~~~

The UDF presentation of the key shares is thus:

~~~~
f(1) = #{Example.UDFSplitShares[0].UDFKey}
f(2) = #{Example.UDFSplitShares[1].UDFKey}
f(3) = #{Example.UDFSplitShares[2].UDFKey}
f(4) = #{Example.UDFSplitShares[3].UDFKey}
f(5) = #{Example.UDFSplitShares[4].UDFKey}
~~~~

To recover the value f(0) from any three shares, we need to fit a polynomial curve to 
the three points and use it to calculate the value at x=0 using the Lagrange polynomial
basis.
#end file

#file UDFDigestLong "Examples\\UDFDigestLong.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var DataString = "UDF Data Value";
#% var Data = DataString.ToUTF8();
#% var ContentType = "text/plain";

In the following examples, &<Content-ID> is the UTF8 encoding of the string 
"#{ContentType}" and &<Data> is the UTF8 encoding of the string "#{DataString}"

~~~~
Data = #{ DataString.ToUTF8().ToStringBase16FormatHex()}

ContentType = #{ContentType.ToUTF8().ToStringBase16FormatHex()}
~~~~

######Using SHA-2-512 Digest

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, null);

This fingerprint MAY be specified with higher or lower precision as appropriate.

<dl>
<dt>100 bit precision
<dd>#{UDF.ContentDigestOfDataString(Data, ContentType, 100)}
<dt>120 bit precision
<dd>#{UDF.ContentDigestOfDataString(Data, ContentType, 120)}
<dt>200 bit precision
<dd>#{UDF.ContentDigestOfDataString(Data, ContentType, 200)}
<dt>260 bit precision
<dd>#{UDF.ContentDigestOfDataString(Data, ContentType, 260)}
</dl>

######Using SHA-3-512 Digest

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_3_512, null);

#end file

#method3 MakeUTFExtendedExample string DataString CryptoAlgorithmID cryptoAlgorithmID string key
#% var DataBytes = DataString.ToUTF8();
#% var ContentType = "text/plain";
#% var HashData = DataBytes.GetDigest(cryptoAlgorithmID);
#% var UDFDataBuffer = UDF.UDFBuffer(HashData, ContentType);
#% byte[] UDFData ;

~~~~
H(&<Data>) = #!
#{HashData.ToStringBase16FormatHex()}

&<Content-ID> + ‘:’ + H(&<Data>) =  #!
#{UDFDataBuffer.ToStringBase16FormatHex()}

#if (key == null)
#% UDFData = UDFDataBuffer.GetDigest(cryptoAlgorithmID);
H(&<Content-ID> + ‘:’ + H(&<Data>)) =  #!
#else
#% var keyBytes = key.ToUTF8();
#% var macKey = UDF.KeyStringToKey(key,512);
#% UDFData = UDFDataBuffer.GetMAC(macKey, CryptoAlgorithmID.HMAC_SHA_2_512);
#% var keyDerive = new KeyDeriveHKDF(keyBytes, KeyDerive.KeyedUDFMaster, CryptoAlgorithmID.HMAC_SHA_2_512);
PRK(Key) =  #!
#{keyDerive.PRK.ToStringBase16FormatHex()}

HKDF(Key) =  #!
#{macKey.ToStringBase16FormatHex()}

MAC(&<key>, &<Content-ID> + ‘:’ + H(&<Data>)) =  #!
#end if
#% var binaryUDF = UDF.DigestToUDFBinary (HashData, ContentType, 140, cryptoAlgorithmID, key);
#{UDFData.ToStringBase16FormatHex()}

The prefixed Binary Data Sequence is thus#{binaryUDF.ToStringBase16FormatHex()}
~~~~

The 125 bit fingerprint value is #{UDF.PresentationBase32 (binaryUDF, 140)}

#end method3

#file UDFAuthenticatorLong "Examples\\UDFAuthenticatorLong.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var key = "NBQ26-MEZGP-4SVCU-RYOWO-QTURA";
#% var DataString = "Konrad is the traitor";
#% var Data = DataString.ToUTF8();
#% var ContentType = "text/plain";

In the following example, &<Content-ID> is the UTF8 encoding of the string 
"#{ContentType}" and &<Data> is the UTF8 encoding of the string "#{DataString}".
The randomly chosen key is #{key}.

~~~~
Data = #{ DataString.ToUTF8().ToStringBase16FormatHex()}

ContentType = #{ContentType.ToUTF8().ToStringBase16FormatHex()}

Key =  #{ key.ToUTF8().ToStringBase16FormatHex()}
~~~~

Processing is performed in the same manner as an unkeyed fingerprint except that
compression is never used:

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, key);
#!The SHA-3-512 commitment with the same inputs is:
#!#{UDF.DataToFormat(Data, ContentType, 125, CryptoAlgorithmID.SHA_3_512, key)}
#end file


#file UDFDigestResolution "Examples\\UDFDigestResolution.md" CreateExamples Example


#end file


#file UDFEncryptedResolution "Examples\\UDFEncryptedResolution.md" CreateExamples Example


#end file



#file MeshExamplesUDFCompressed "Examples\\ExamplesUDFCompressed.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var ContentType = "text/plain";
#% var ContentTypeString = ContentType.ToUTF8().ToStringBase16FormatHex();
#% var DataString = "290668103";
#% var DataBytes = DataString.ToUTF8();
#% var DataBytesString = DataBytes.ToStringBase16FormatHex();
#% var HashData = Goedel.Cryptography.Platform.SHA2_512.Process(DataBytes).ToStringBase16FormatHex();
#% var UDFDataBuffer = UDF.UDFBuffer(DataBytes, ContentType);
#% var UDFDataBufferString = UDFDataBuffer.ToStringBase16FormatHex();
#% var UDFData = Goedel.Cryptography.Platform.SHA2_512.Process(UDFDataBuffer).ToStringBase16FormatHex();

The string "#{DataString}" has a SHA-2-512 UDF fingerprint with 29 leading zero bits. The inputs
to the fingerprint are:

~~~~
Data = #{DataBytesString}

ContentType = #{ContentTypeString}

H ( &<Content-ID> + ‘:’ + H(&<Data>))= 
#{UDFData}
~~~~

Since the first three bytes of the final hash value are zeros, these are dropped and
the version identifier increased by 1:

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, null);

Note that the use of compression does not reduce the number of characters presented. 
Compression increases the work factor that is achieved for a given fingerprint length
but does not in itself cause the presentation to be changed.

The 125 bit UDF of the string "44870804" using SHA-3-512 is
#!{UDF.DataToFormat("44870804".ToUTF8(), ContentType, 125, CryptoAlgorithmID.SHA_3_512, null)}.

#end file





#file MeshExamplesUDFCommitment "Examples\\ExamplesUDFCommitment.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var key = "RBQ26-MEZGP-4SVCU-RYOWO-QTURA";
#% var DataString = "Konrad is the traitor";
#% var Data = DataString.ToUTF8();
#% var ContentType = "text/plain";

In the following example, &<Content-ID> is the UTF8 encoding of the string 
"#{ContentType}" and &<Data> is the UTF8 encoding of the string "#{DataString}".
The randomly chosen key is #{key}.

~~~~
Data = #{ DataString.ToUTF8().ToStringBase16FormatHex()}

ContentType = #{ContentType.ToUTF8().ToStringBase16FormatHex()}

Key =  #{ key.ToUTF8().ToStringBase16FormatHex()}
~~~~

Processing is performed in the same manner as an unkeyed fingerprint:

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, key);

#!The SHA-3-512 commitment with the same inputs is:
#!#{UDF.DataToFormat(Data, ContentType, 125, CryptoAlgorithmID.SHA_3_512, key)}

#end file




#file MeshExamplesSIN "Examples\\ExamplesSIN.md" CreateExamples Example

A SIN is an Internet Identifier that contains a fingerprint of a root of 
trust that may be used to verify the interpretation of the identifier. This 
section describes the manner in which SINs are used. The following section describes 
their construction using Uniform Data Fingerprints [I-D.hallambaker-udf]

For example, Example Inc holds the domain name example.com and has deployed a private 
CA whose root of trust is a PKIX certificate with the UDF fingerprint MB2GK-6DUF5-YGYYL-JNY5E-RWSHZ.

Alice is an employee of Example Inc., she uses three email addresses:

alice@example.com
A regular email address (not a SIN).
alice@mm--mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
A strong email address that is backwards compatible.
alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
A strong email address that is backwards incompatible.
All three forms of the address are valid RFC822 addresses and may be used in a legacy 
email client, stored in an address book application, etc. But the ability of a legacy 
client to make use of the address differs. Addresses of the first type may always be used. 
Addresses of the second type may only be used if an appropriate MX record is provisioned. 
Addresses of the third type will always fail unless the resolver understands that it is a 
SIN requiring special processing.

When specified as the destination address in a Mail User Application (MUA), these addresses 
have the following interpretations:

alice@example.com
Send mail to Alice without requiring security enhancements.
alice@mm--mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
Send mail to Alice. If the MUA is SIN-Aware, it MUST resolve the security policy specified 
by the fingerprint and apply security enhancements as mandated by that policy.
alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
Only send mail to Alice if the MUA is SIN-Aware, it MUST resolve the security policy 
specified by the fingerprint and apply security enhancements as mandated by that policy.
These rules allow Bob to send email to Alice with either ‘best effort’ security or 
mandatory security as the circumstances demand

#end file

#file MeshExamplesSIN2 "Examples\\ExamplesSIN2.md" CreateExamples Example

A security policy may be implicit or explicit depending on the root of trust referenced and the context in which it is used.

Since many Internet applications are already designed to make use of a PKIX based trust infrastructure, the fingerprint of a PKIX root of trust provides sufficient information to deduce an appropriate security policy in many instances. For example:

https://mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com/
Connect to example.com using a TLS connection with a certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.
IMAP Server: mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
Connect to the IMAP server example.com over a TLS connection with a certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.
mailto:alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
Encrypt mail messages using S/MIME using an S/MIME certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.

#end file


#file MeshManToolFile "Examples\\MeshManToolFile.md" CreateExamples Example

The file command set supports the following operations on files:

<dl>
<dt>random
<dd>Return a randomized string
<dt>digest
<dd>Calculate the digest value of the input data
<dt>commit
<dd>Calculate a commitment value for the input data
<dt>encode
</dl>


####Command random

The random command returns a randomized string in UDF format containing at
least 117 bits of random data.

The random command may be used to in scripts to generate temporary passwords 
that are to be deleted as soon as the script completes.

For example, Alice wants to export her GPG key from her Mesh profile to a local
file that can be input to her GPG mail application. She enters the following 
commands:


While this approach successfully configures her mail application, her private key
was written to the hard drive of the machine in the process. Even though she
used the delete command to remove the file containg the private key, this is
unlikely to prevent recovery using forensic tools on the storage media.

Encrypting the private key file under a randomly generated password is a
much more robust approach. But only if we make sure that our password does
not get written out to the disk either.

<ul>
<li>Disable the shell command history feature.
<li>Generate a random password.
<li>Export the private key encrypted under the random password.
<li>Import the private key to the application.
<li>Delete the private key file.
<li>Restart the machine to erase the password from memory.
</ul>

This is achieved using the following shell commands:


export HISTFILE=/dev/null

####Command digest


####Command commit

#end file

#end xclass
