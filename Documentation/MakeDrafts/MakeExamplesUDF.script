#using System.Text
#using Goedel.Mesh
#using Goedel.Protocol
#using Goedel.Utilities
#using Goedel.Cryptography
#using Goedel.Cryptography.Dare
#xclass ExampleGenerator ExampleGenerator
#% static ExampleGenerator Instance(StreamWriter output)  => new ExampleGenerator () { _Output = output};



#file MeshExamplesUDF "Examples\\ExamplesUDF.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var DataString = "UDF Data Value";
#% var Data = DataString.ToUTF8();
#% var ContentType = "text/plain";

In the following examples, &<Content-ID> is the UTF8 encoding of the string 
"#{ContentType}" and &<Data> is the UTF8 encoding of the string "#{DataString}"

~~~~
Data = #{ DataString.ToUTF8().ToStringBase16FormatHex()}

ContentType = #{ContentType.ToUTF8().ToStringBase16FormatHex()}
~~~~

######Using SHA-2-512 Digest

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, null);

This fingerprint MAY be specified with higher or lower precision as appropriate.

<dl>
<dt>100 bit precision
<dd>#{UDF.DataToFormat(Data, ContentType, 100)}
<dt>150 bit precision
<dd>#{UDF.DataToFormat(Data, ContentType, 150)}
<dt>200 bit precision
<dd>#{UDF.DataToFormat(Data, ContentType, 200)}
<dt>250 bit precision
<dd>#{UDF.DataToFormat(Data, ContentType, 250)}
</dl>

######Using SHA-3-512 Digest

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_3_512, null);

#end file

#file MeshExamplesUDFCompressed "Examples\\ExamplesUDFCompressed.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var ContentType = "text/plain";
#% var ContentTypeString = ContentType.ToUTF8().ToStringBase16FormatHex();
#% var DataString = "290668103";
#% var DataBytes = DataString.ToUTF8();
#% var DataBytesString = DataBytes.ToStringBase16FormatHex();
#% var HashData = Goedel.Cryptography.Platform.SHA2_512.Process(DataBytes).ToStringBase16FormatHex();
#% var UDFDataBuffer = UDF.UDFBuffer(DataBytes, ContentType);
#% var UDFDataBufferString = UDFDataBuffer.ToStringBase16FormatHex();
#% var UDFData = Goedel.Cryptography.Platform.SHA2_512.Process(UDFDataBuffer).ToStringBase16FormatHex();

The string "#{DataString}" has a SHA-2-512 UDF fingerprint with 29 leading zero bits. The inputs
to the fingerprint are:

~~~~
Data = #{DataBytesString}

ContentType = #{ContentTypeString}

H ( &<Content-ID> + ‘:’ + H(&<Data>))= 
#{UDFData}
~~~~

Since the first three bytes of the final hash value are zeros, these are dropped and
the version identifier increased by 1:

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, null);

Note that the use of compression does not reduce the number of characters presented. 
Compression increases the work factor that is achieved for a given fingerprint length
but does not in itself cause the presentation to be changed.

The 125 bit UDF of the string "44870804" using SHA-3-512 is
#{UDF.DataToFormat("44870804".ToUTF8(), ContentType, 125, CryptoAlgorithmID.SHA_3_512, null)}.

#end file

#file MeshExamplesUDFCommitment "Examples\\ExamplesUDFCommitment.md" CreateExamples Example
#% var instance = Instance (_Output);
#% var key = "RBQ26-MEZGP-4SVCU-RYOWO-QTURA";
#% var DataString = "Konrad is the traitor";
#% var Data = DataString.ToUTF8();
#% var ContentType = "text/plain";

In the following example, &<Content-ID> is the UTF8 encoding of the string 
"#{ContentType}" and &<Data> is the UTF8 encoding of the string "#{DataString}".
The randomly chosen key is #{key}.

~~~~
Data = #{ DataString.ToUTF8().ToStringBase16FormatHex()}

ContentType = #{ContentType.ToUTF8().ToStringBase16FormatHex()}

Key =  #{ key.ToUTF8().ToStringBase16FormatHex()}
~~~~

Processing is performed in the same manner as an unkeyed fingerprint:

#% instance.MakeUTFExtendedExample (DataString, CryptoAlgorithmID.SHA_2_512, key);

The SHA-3-512 commitment with the same inputs is:
#{UDF.DataToFormat(Data, ContentType, 125, CryptoAlgorithmID.SHA_3_512, key)}

#end file

#method3 MakeUTFExtendedExample string DataString CryptoAlgorithmID cryptoAlgorithmID string key
#% var DataBytes = DataString.ToUTF8();
#% var ContentType = "text/plain";
#% var HashData = DataBytes.GetDigest(cryptoAlgorithmID);
#% var UDFDataBuffer = UDF.UDFBuffer(HashData, ContentType, key);
#% var UDFData = UDFDataBuffer.GetDigest(cryptoAlgorithmID);
#% var Trimmed=UDF.BufferDigestToUDF(UDFDataBuffer,125,cryptoAlgorithmID);

~~~~
H(&<Data>) = 
#{HashData.ToStringBase16FormatHex()}

#if (key == null)
&<Content-ID> + ‘:’ + H(&<Data>) = 
#else
&<Content-ID> + ‘:’ + H(&<Data>) + ‘:’ + &<key> = 
#end if
#{UDFDataBuffer.ToStringBase16FormatHex()}

#if (key == null)
H(&<Content-ID> + ‘:’ + H(&<Data>)) = 
#else
H(&<Content-ID> + ‘:’ + H(&<Data>) + ‘:’ + &<key>) = 
#end if
#{UDFData.ToStringBase16FormatHex()}

Prefixed, compressed, trimmed =
#{Trimmed.ToStringBase16FormatHex()} ...
~~~~

The 125 bit fingerprint value is #{UDF.Format (Trimmed, 125)}

#end method3


#file MeshExamplesSIN "Examples\\ExamplesSIN.md" CreateExamples Example

A SIN is an Internet Identifier that contains a fingerprint of a root of trust that may be used to verify the interpretation of the identifier. This section describes the manner in which SINs are used. The following section describes their construction using Uniform Data Fingerprints [I-D.hallambaker-udf]

For example, Example Inc holds the domain name example.com and has deployed a private CA whose root of trust is a PKIX certificate with the UDF fingerprint MB2GK-6DUF5-YGYYL-JNY5E-RWSHZ.

Alice is an employee of Example Inc., she uses three email addresses:

alice@example.com
A regular email address (not a SIN).
alice@mm--mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
A strong email address that is backwards compatible.
alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
A strong email address that is backwards incompatible.
All three forms of the address are valid RFC822 addresses and may be used in a legacy email client, stored in an address book application, etc. But the ability of a legacy client to make use of the address differs. Addresses of the first type may always be used. Addresses of the second type may only be used if an appropriate MX record is provisioned. Addresses of the third type will always fail unless the resolver understands that it is a SIN requiring special processing.

When specified as the destination address in a Mail User Application (MUA), these addresses have the following interpretations:

alice@example.com
Send mail to Alice without requiring security enhancements.
alice@mm--mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
Send mail to Alice. If the MUA is SIN-Aware, it MUST resolve the security policy specified by the fingerprint and apply security enhancements as mandated by that policy.
alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
Only send mail to Alice if the MUA is SIN-Aware, it MUST resolve the security policy specified by the fingerprint and apply security enhancements as mandated by that policy.
These rules allow Bob to send email to Alice with either ‘best effort’ security or mandatory security as the circumstances demand

#end file

#file MeshExamplesSIN2 "Examples\\ExamplesSIN2.md" CreateExamples Example

A security policy may be implicit or explicit depending on the root of trust referenced and the context in which it is used.

Since many Internet applications are already designed to make use of a PKIX based trust infrastructure, the fingerprint of a PKIX root of trust provides sufficient information to deduce an appropriate security policy in many instances. For example:

https://mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com/
Connect to example.com using a TLS connection with a certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.
IMAP Server: mb2gk-6duf5-ygyyl-jny5e-rwshz.example.com
Connect to the IMAP server example.com over a TLS connection with a certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.
mailto:alice@example.com.mm--mb2gk-6duf5-ygyyl-jny5e-rwshz
Encrypt mail messages using S/MIME using an S/MIME certificate that is valid in a chain of trust that contains a certificate with the fingerprint mb2gk.

#end file





#end xclass
